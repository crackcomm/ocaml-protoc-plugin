(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: google/protobuf/api.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving sexp_of]'
    opens=[Core]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Core [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Source_context = Source_context
  module Type = Type
end
(**/**)
module Google = struct
  module Protobuf = struct
    module rec Api : sig
      val name': unit -> string
      type t = { name: string; methods: Method.t list; options: Imported'modules.Type.Google.Protobuf.Option.t list; version: string; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; mixins: Mixin.t list; syntax: Imported'modules.Type.Google.Protobuf.Syntax.t } [@@deriving sexp_of]
      val make : ?name:string -> ?methods:Method.t list -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?version:string -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?mixins:Mixin.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "api.google.protobuf.Api"
      type t = { name: string; methods: Method.t list; options: Imported'modules.Type.Google.Protobuf.Option.t list; version: string; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; mixins: Mixin.t list; syntax: Imported'modules.Type.Google.Protobuf.Syntax.t }[@@deriving sexp_of]
      let make =
        fun ?name ?methods ?options ?version ?source_context ?mixins ?syntax () -> 
        let name = match name with Some v -> v | None -> {||} in
        let methods = match methods with Some v -> v | None -> [] in
        let options = match options with Some v -> v | None -> [] in
        let version = match version with Some v -> v | None -> {||} in
        let mixins = match mixins with Some v -> v | None -> [] in
        let syntax = match syntax with Some v -> v | None -> (Imported'modules.Type.Google.Protobuf.Syntax.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        { name; methods; options; version; source_context; mixins; syntax }
      
      let to_proto =
        let apply = fun ~f:f' { name; methods; options; version; source_context; mixins; syntax } -> f' [] name methods options version source_context mixins syntax in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Method.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Imported'modules.Type.Google.Protobuf.Option.to_proto t)), not_packed) ^:: basic (4, string, proto3) ^:: basic_opt (5, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.to_proto t))) ^:: repeated (6, (message (fun t -> Mixin.to_proto t)), not_packed) ^:: basic (7, (enum Imported'modules.Type.Google.Protobuf.Syntax.to_int), proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name methods options version source_context mixins syntax -> { name; methods; options; version; source_context; mixins; syntax } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Method.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Imported'modules.Type.Google.Protobuf.Option.from_proto t)), not_packed) ^:: basic (4, string, proto3) ^:: basic_opt (5, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.from_proto t))) ^:: repeated (6, (message (fun t -> Mixin.from_proto t)), not_packed) ^:: basic (7, (enum Imported'modules.Type.Google.Protobuf.Syntax.from_int), proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Method : sig
      val name': unit -> string
      type t = { name: string; request_type_url: string; request_streaming: bool; response_type_url: string; response_streaming: bool; options: Imported'modules.Type.Google.Protobuf.Option.t list; syntax: Imported'modules.Type.Google.Protobuf.Syntax.t } [@@deriving sexp_of]
      val make : ?name:string -> ?request_type_url:string -> ?request_streaming:bool -> ?response_type_url:string -> ?response_streaming:bool -> ?options:Imported'modules.Type.Google.Protobuf.Option.t list -> ?syntax:Imported'modules.Type.Google.Protobuf.Syntax.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "api.google.protobuf.Method"
      type t = { name: string; request_type_url: string; request_streaming: bool; response_type_url: string; response_streaming: bool; options: Imported'modules.Type.Google.Protobuf.Option.t list; syntax: Imported'modules.Type.Google.Protobuf.Syntax.t }[@@deriving sexp_of]
      let make =
        fun ?name ?request_type_url ?request_streaming ?response_type_url ?response_streaming ?options ?syntax () -> 
        let name = match name with Some v -> v | None -> {||} in
        let request_type_url = match request_type_url with Some v -> v | None -> {||} in
        let request_streaming = match request_streaming with Some v -> v | None -> false in
        let response_type_url = match response_type_url with Some v -> v | None -> {||} in
        let response_streaming = match response_streaming with Some v -> v | None -> false in
        let options = match options with Some v -> v | None -> [] in
        let syntax = match syntax with Some v -> v | None -> (Imported'modules.Type.Google.Protobuf.Syntax.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax }
      
      let to_proto =
        let apply = fun ~f:f' { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } -> f' [] name request_type_url request_streaming response_type_url response_streaming options syntax in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Imported'modules.Type.Google.Protobuf.Option.to_proto t)), not_packed) ^:: basic (7, (enum Imported'modules.Type.Google.Protobuf.Syntax.to_int), proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name request_type_url request_streaming response_type_url response_streaming options syntax -> { name; request_type_url; request_streaming; response_type_url; response_streaming; options; syntax } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Imported'modules.Type.Google.Protobuf.Option.from_proto t)), not_packed) ^:: basic (7, (enum Imported'modules.Type.Google.Protobuf.Syntax.from_int), proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Mixin : sig
      val name': unit -> string
      type t = { name: string; root: string } [@@deriving sexp_of]
      val make : ?name:string -> ?root:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "api.google.protobuf.Mixin"
      type t = { name: string; root: string }[@@deriving sexp_of]
      let make =
        fun ?name ?root () -> 
        let name = match name with Some v -> v | None -> {||} in
        let root = match root with Some v -> v | None -> {||} in
        { name; root }
      
      let to_proto =
        let apply = fun ~f:f' { name; root } -> f' [] name root in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name root -> { name; root } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
  end
end