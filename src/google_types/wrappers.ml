(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: google/protobuf/wrappers.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving sexp_of]'
    opens=[Core]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Core [@@warning "-33"]
module Google = struct
  module Protobuf = struct
    module rec DoubleValue : sig
      val name': unit -> string
      type t = float [@@deriving sexp_of]
      val make : ?value:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.DoubleValue"
      type t = float[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0. in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, double, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, double, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and FloatValue : sig
      val name': unit -> string
      type t = float [@@deriving sexp_of]
      val make : ?value:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.FloatValue"
      type t = float[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0. in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, float, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, float, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Int64Value : sig
      val name': unit -> string
      type t = int [@@deriving sexp_of]
      val make : ?value:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.Int64Value"
      type t = int[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0 in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, int64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and UInt64Value : sig
      val name': unit -> string
      type t = int [@@deriving sexp_of]
      val make : ?value:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.UInt64Value"
      type t = int[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0 in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Int32Value : sig
      val name': unit -> string
      type t = int [@@deriving sexp_of]
      val make : ?value:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.Int32Value"
      type t = int[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0 in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and UInt32Value : sig
      val name': unit -> string
      type t = int [@@deriving sexp_of]
      val make : ?value:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.UInt32Value"
      type t = int[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> 0 in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and BoolValue : sig
      val name': unit -> string
      type t = bool [@@deriving sexp_of]
      val make : ?value:bool -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.BoolValue"
      type t = bool[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> false in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and StringValue : sig
      val name': unit -> string
      type t = string [@@deriving sexp_of]
      val make : ?value:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.StringValue"
      type t = string[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> {||} in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and BytesValue : sig
      val name': unit -> string
      type t = bytes [@@deriving sexp_of]
      val make : ?value:bytes -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "wrappers.google.protobuf.BytesValue"
      type t = bytes[@@deriving sexp_of]
      let make =
        fun ?value () -> 
        let value = match value with Some v -> v | None -> (Bytes.of_string {||}) in
        value
      
      let to_proto =
        let apply = fun ~f:f' value -> f' [] value in
        let spec = Runtime'.Serialize.C.( basic (1, bytes, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions value -> value in
        let spec = Runtime'.Deserialize.C.( basic (1, bytes, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
  end
end