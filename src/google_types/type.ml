(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: google/protobuf/type.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving sexp_of]'
    opens=[Core]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Core [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Any = Any
  module Source_context = Source_context
end
(**/**)
module Google = struct
  module Protobuf = struct
    module rec Syntax : sig
      type t = SYNTAX_PROTO2 | SYNTAX_PROTO3 [@@deriving sexp_of]
      val to_int: t -> int
      val from_int: int -> (t, [> Runtime'.Result.error]) result
    end = struct 
      type t = SYNTAX_PROTO2 | SYNTAX_PROTO3 [@@deriving sexp_of]
      let to_int = function
        | SYNTAX_PROTO2 -> 0
        | SYNTAX_PROTO3 -> 1
      
      let from_int = function
        | 0 -> Ok SYNTAX_PROTO2
        | 1 -> Ok SYNTAX_PROTO3
        | n -> Error (`Unknown_enum_value n)
      
    end
    and Type : sig
      val name': unit -> string
      type t = { name: string; fields: Field.t list; oneofs: string list; options: Option.t list; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; syntax: Syntax.t } [@@deriving sexp_of]
      val make : ?name:string -> ?fields:Field.t list -> ?oneofs:string list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "type.google.protobuf.Type"
      type t = { name: string; fields: Field.t list; oneofs: string list; options: Option.t list; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; syntax: Syntax.t }[@@deriving sexp_of]
      let make =
        fun ?name ?fields ?oneofs ?options ?source_context ?syntax () -> 
        let name = match name with Some v -> v | None -> {||} in
        let fields = match fields with Some v -> v | None -> [] in
        let oneofs = match oneofs with Some v -> v | None -> [] in
        let options = match options with Some v -> v | None -> [] in
        let syntax = match syntax with Some v -> v | None -> (Syntax.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        { name; fields; oneofs; options; source_context; syntax }
      
      let to_proto =
        let apply = fun ~f:f' { name; fields; oneofs; options; source_context; syntax } -> f' [] name fields oneofs options source_context syntax in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Field.to_proto t)), not_packed) ^:: repeated (3, string, packed) ^:: repeated (4, (message (fun t -> Option.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.to_proto t))) ^:: basic (6, (enum Syntax.to_int), proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name fields oneofs options source_context syntax -> { name; fields; oneofs; options; source_context; syntax } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Field.from_proto t)), not_packed) ^:: repeated (3, string, packed) ^:: repeated (4, (message (fun t -> Option.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.from_proto t))) ^:: basic (6, (enum Syntax.from_int), proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Field : sig
      module rec Kind : sig
        type t = TYPE_UNKNOWN | TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64 [@@deriving sexp_of]
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end
      and Cardinality : sig
        type t = CARDINALITY_UNKNOWN | CARDINALITY_OPTIONAL | CARDINALITY_REQUIRED | CARDINALITY_REPEATED [@@deriving sexp_of]
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end
      val name': unit -> string
      type t = { kind: Field.Kind.t; cardinality: Field.Cardinality.t; number: int; name: string; type_url: string; oneof_index: int; packed: bool; options: Option.t list; json_name: string; default_value: string } [@@deriving sexp_of]
      val make : ?kind:Field.Kind.t -> ?cardinality:Field.Cardinality.t -> ?number:int -> ?name:string -> ?type_url:string -> ?oneof_index:int -> ?packed:bool -> ?options:Option.t list -> ?json_name:string -> ?default_value:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      module rec Kind : sig
        type t = TYPE_UNKNOWN | TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64 [@@deriving sexp_of]
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end = struct 
        type t = TYPE_UNKNOWN | TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT64 | TYPE_UINT64 | TYPE_INT32 | TYPE_FIXED64 | TYPE_FIXED32 | TYPE_BOOL | TYPE_STRING | TYPE_GROUP | TYPE_MESSAGE | TYPE_BYTES | TYPE_UINT32 | TYPE_ENUM | TYPE_SFIXED32 | TYPE_SFIXED64 | TYPE_SINT32 | TYPE_SINT64 [@@deriving sexp_of]
        let to_int = function
          | TYPE_UNKNOWN -> 0
          | TYPE_DOUBLE -> 1
          | TYPE_FLOAT -> 2
          | TYPE_INT64 -> 3
          | TYPE_UINT64 -> 4
          | TYPE_INT32 -> 5
          | TYPE_FIXED64 -> 6
          | TYPE_FIXED32 -> 7
          | TYPE_BOOL -> 8
          | TYPE_STRING -> 9
          | TYPE_GROUP -> 10
          | TYPE_MESSAGE -> 11
          | TYPE_BYTES -> 12
          | TYPE_UINT32 -> 13
          | TYPE_ENUM -> 14
          | TYPE_SFIXED32 -> 15
          | TYPE_SFIXED64 -> 16
          | TYPE_SINT32 -> 17
          | TYPE_SINT64 -> 18
        
        let from_int = function
          | 0 -> Ok TYPE_UNKNOWN
          | 1 -> Ok TYPE_DOUBLE
          | 2 -> Ok TYPE_FLOAT
          | 3 -> Ok TYPE_INT64
          | 4 -> Ok TYPE_UINT64
          | 5 -> Ok TYPE_INT32
          | 6 -> Ok TYPE_FIXED64
          | 7 -> Ok TYPE_FIXED32
          | 8 -> Ok TYPE_BOOL
          | 9 -> Ok TYPE_STRING
          | 10 -> Ok TYPE_GROUP
          | 11 -> Ok TYPE_MESSAGE
          | 12 -> Ok TYPE_BYTES
          | 13 -> Ok TYPE_UINT32
          | 14 -> Ok TYPE_ENUM
          | 15 -> Ok TYPE_SFIXED32
          | 16 -> Ok TYPE_SFIXED64
          | 17 -> Ok TYPE_SINT32
          | 18 -> Ok TYPE_SINT64
          | n -> Error (`Unknown_enum_value n)
        
      end
      and Cardinality : sig
        type t = CARDINALITY_UNKNOWN | CARDINALITY_OPTIONAL | CARDINALITY_REQUIRED | CARDINALITY_REPEATED [@@deriving sexp_of]
        val to_int: t -> int
        val from_int: int -> (t, [> Runtime'.Result.error]) result
      end = struct 
        type t = CARDINALITY_UNKNOWN | CARDINALITY_OPTIONAL | CARDINALITY_REQUIRED | CARDINALITY_REPEATED [@@deriving sexp_of]
        let to_int = function
          | CARDINALITY_UNKNOWN -> 0
          | CARDINALITY_OPTIONAL -> 1
          | CARDINALITY_REQUIRED -> 2
          | CARDINALITY_REPEATED -> 3
        
        let from_int = function
          | 0 -> Ok CARDINALITY_UNKNOWN
          | 1 -> Ok CARDINALITY_OPTIONAL
          | 2 -> Ok CARDINALITY_REQUIRED
          | 3 -> Ok CARDINALITY_REPEATED
          | n -> Error (`Unknown_enum_value n)
        
      end
      let name' () = "type.google.protobuf.Field"
      type t = { kind: Field.Kind.t; cardinality: Field.Cardinality.t; number: int; name: string; type_url: string; oneof_index: int; packed: bool; options: Option.t list; json_name: string; default_value: string }[@@deriving sexp_of]
      let make =
        fun ?kind ?cardinality ?number ?name ?type_url ?oneof_index ?packed ?options ?json_name ?default_value () -> 
        let kind = match kind with Some v -> v | None -> (Field.Kind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        let cardinality = match cardinality with Some v -> v | None -> (Field.Cardinality.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        let number = match number with Some v -> v | None -> 0 in
        let name = match name with Some v -> v | None -> {||} in
        let type_url = match type_url with Some v -> v | None -> {||} in
        let oneof_index = match oneof_index with Some v -> v | None -> 0 in
        let packed = match packed with Some v -> v | None -> false in
        let options = match options with Some v -> v | None -> [] in
        let json_name = match json_name with Some v -> v | None -> {||} in
        let default_value = match default_value with Some v -> v | None -> {||} in
        { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value }
      
      let to_proto =
        let apply = fun ~f:f' { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } -> f' [] kind cardinality number name type_url oneof_index packed options json_name default_value in
        let spec = Runtime'.Serialize.C.( basic (1, (enum Field.Kind.to_int), proto3) ^:: basic (2, (enum Field.Cardinality.to_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, string, proto3) ^:: basic (6, string, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: repeated (9, (message (fun t -> Option.to_proto t)), not_packed) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions kind cardinality number name type_url oneof_index packed options json_name default_value -> { kind; cardinality; number; name; type_url; oneof_index; packed; options; json_name; default_value } in
        let spec = Runtime'.Deserialize.C.( basic (1, (enum Field.Kind.from_int), proto3) ^:: basic (2, (enum Field.Cardinality.from_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, string, proto3) ^:: basic (6, string, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: repeated (9, (message (fun t -> Option.from_proto t)), not_packed) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Enum : sig
      val name': unit -> string
      type t = { name: string; enumvalue: EnumValue.t list; options: Option.t list; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; syntax: Syntax.t } [@@deriving sexp_of]
      val make : ?name:string -> ?enumvalue:EnumValue.t list -> ?options:Option.t list -> ?source_context:Imported'modules.Source_context.Google.Protobuf.SourceContext.t -> ?syntax:Syntax.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "type.google.protobuf.Enum"
      type t = { name: string; enumvalue: EnumValue.t list; options: Option.t list; source_context: Imported'modules.Source_context.Google.Protobuf.SourceContext.t option; syntax: Syntax.t }[@@deriving sexp_of]
      let make =
        fun ?name ?enumvalue ?options ?source_context ?syntax () -> 
        let name = match name with Some v -> v | None -> {||} in
        let enumvalue = match enumvalue with Some v -> v | None -> [] in
        let options = match options with Some v -> v | None -> [] in
        let syntax = match syntax with Some v -> v | None -> (Syntax.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
        { name; enumvalue; options; source_context; syntax }
      
      let to_proto =
        let apply = fun ~f:f' { name; enumvalue; options; source_context; syntax } -> f' [] name enumvalue options source_context syntax in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> EnumValue.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Option.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.to_proto t))) ^:: basic (5, (enum Syntax.to_int), proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name enumvalue options source_context syntax -> { name; enumvalue; options; source_context; syntax } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> EnumValue.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Option.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Imported'modules.Source_context.Google.Protobuf.SourceContext.from_proto t))) ^:: basic (5, (enum Syntax.from_int), proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and EnumValue : sig
      val name': unit -> string
      type t = { name: string; number: int; options: Option.t list } [@@deriving sexp_of]
      val make : ?name:string -> ?number:int -> ?options:Option.t list -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "type.google.protobuf.EnumValue"
      type t = { name: string; number: int; options: Option.t list }[@@deriving sexp_of]
      let make =
        fun ?name ?number ?options () -> 
        let name = match name with Some v -> v | None -> {||} in
        let number = match number with Some v -> v | None -> 0 in
        let options = match options with Some v -> v | None -> [] in
        { name; number; options }
      
      let to_proto =
        let apply = fun ~f:f' { name; number; options } -> f' [] name number options in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: repeated (3, (message (fun t -> Option.to_proto t)), not_packed) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name number options -> { name; number; options } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: repeated (3, (message (fun t -> Option.from_proto t)), not_packed) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    and Option : sig
      val name': unit -> string
      type t = { name: string; value: Imported'modules.Any.Google.Protobuf.Any.t option } [@@deriving sexp_of]
      val make : ?name:string -> ?value:Imported'modules.Any.Google.Protobuf.Any.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "type.google.protobuf.Option"
      type t = { name: string; value: Imported'modules.Any.Google.Protobuf.Any.t option }[@@deriving sexp_of]
      let make =
        fun ?name ?value () -> 
        let name = match name with Some v -> v | None -> {||} in
        { name; value }
      
      let to_proto =
        let apply = fun ~f:f' { name; value } -> f' [] name value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions name value -> { name; value } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
  end
end